optimizeMeanVariancePortfolio <- function(meanVector, covarianceMatrix, horizonPriceVector, horizonPnLMatrix, wealthBalance, maxWeightConstraint, colNames,longOnly){
  
  returnBoundary <- 3000
  resetReturnBoundary <- returnBoundary
  returnBoundaryFloor <- -1000
  resetReturnBoundaryFloor <- returnBoundaryFloor
  isRunRequired <- TRUE
  numRuns <- 300
  boundaryStep <- 5
  
  minHoldings <- ifelse(longOnly,0,-10000) #these are holdings
  
  covarianceMatrixReturnsBased <- covRob(data = sapply(1:length(horizonPriceVector),function(x){horizonPnLMatrix[,x] / horizonPriceVector[x]}))$cov
  
  while(isRunRequired)
  {
    
    isRunRequired <- FALSE
    
    #the return boundary can cause errors, so we shrink it until we get feasible solutions
    tryCatch( 
      QuadProgFrontier <- lapply(seq(  from = mean(meanVector)*returnBoundaryFloor
                                       , to = mean(meanVector)*returnBoundary
                                       , len = numRuns
      )
      ,function(x){
        numSecurities <- ncol(covarianceMatrix)
        solution<-solve.QP(Dmat = covarianceMatrix
                           , dvec = meanVector
                           , Amat = t(rbind(   rep(1,numSecurities)*horizonPriceVector #full budget invest
                                               , rep(1,numSecurities)*meanVector #min return
                                               , diag(numSecurities) #greater than 0, no shorting
                                               , diag(numSecurities)*-1*horizonPriceVector #max allocation
                           ))
                           , bvec = c(        wealthBalance #full budget invest
                                              , x #vary minimum return required
                                              ,rep(minHoldings,numSecurities) #greater than 0, no shorting
                                              , rep(-wealthBalance,numSecurities)*ifelse(colNames %in% maxWeightConstraint$names, maxWeightConstraint$maxWeight, maxWeightConstraint$constraintWeight)
                           )
                           , meq = 2)
        return(solution$solution)
      }
      )
      
      , error = function(e){
        if(returnBoundary == resetReturnBoundary & returnBoundaryFloor == resetReturnBoundaryFloor){print(paste("Error, reducing boundary"))}
        
        returnBoundary <<- returnBoundary - boundaryStep
        
        if(returnBoundary<2){
          returnBoundaryFloor <<- returnBoundaryFloor + boundaryStep
          returnBoundary <<- resetReturnBoundary
        }
        
        
        #print(paste("Error, reducing boundary floor to", returnBoundaryFloor))
        
        isRunRequired <<- TRUE
      }
      #, finally = {print("Completed")}
    )
  }
  print("Completed")
  
  #print(QuadProgFrontier)
  
  #now calculate statistics
  QuadProgFrontierStats <- lapply(QuadProgFrontier
                                  ,function(Holdings){
                                    holdingToWeight <- as.vector((Holdings * horizonPriceVector)/sum(Holdings * horizonPriceVector))
                                    covariance <- covarianceMatrixReturnsBased
                                    
                                    portfolioValue <- sum(as.vector(Holdings * horizonPriceVector))
                                    
                                    
                                    aggResult <- list(
                                      weights = holdingToWeight
                                      , holdings = as.vector(Holdings)
                                      , expectedReturns = sum(as.vector(Holdings * meanVector)/portfolioValue)
                                      , standardDeviation = sqrt(holdingToWeight %*%  covariance %*% holdingToWeight)
                                    )
                                    
                                    return(aggResult)
                                    
                                  }
  )
  #   ####ER --->>> 
  #   sum(
  #     as.vector(QuadProdFrontier[[1]] * apply(SectorSPDRHorizonPnL,2,mean)
  #     )
  #     /
  #       sum(QuadProdFrontier[[1]] * coredata(SectorSPDRPrices[nrow(SectorSPDRPrices),]))
  #   )
  #print(paste("holdings: ",QuadProgFrontierStats[[1]]$holdings))
  #print(paste("std: ",QuadProgFrontierStats[[1]]$standardDeviation))
  
  holdings<-do.call(rbind,lapply(QuadProgFrontierStats
                                 ,function(FStats){
                                   HLD<-round(FStats$holdings,5)
                                   return(HLD)
                                 }
  )
  )
  
  expectedReturn<-sapply(QuadProgFrontierStats
                         ,function(FStats){
                           ER<-round(FStats$expectedReturns,5)
                           return(ER)
                         }
  )
  
  standardDeviation<-sapply(QuadProgFrontierStats
                            ,function(FStats){
                              SD<-round(FStats$standardDeviation,5)
                              return(SD)
                            }
  )
  ###standardDeviation <- do.call(c,standardDeviation)
  #Why are there two of these?
  weights<-lapply(QuadProgFrontierStats
                  ,function(FStats){
                    WT<-round(FStats$weights,5)
                    return(WT)
                  }
  )
  
  #print(class(weights))
  #print(weights)
  
  #   weights <- lapply(weights
  #                     ,function(wRow){
  #                       wt<-(wRow*horizonPriceVector)/sum(wRow*horizonPriceVector)
  #                       return(wt)
  #                     }
  #   )
  
  weights <- do.call(rbind, weights)  
  
  optimalIdx <- which((expectedReturn/standardDeviation)==max(expectedReturn/standardDeviation))
  
  
  QuadProgFrontierResults <- list(holdings = holdings
                                  , weights = weights
                                  , expectedReturn = expectedReturn
                                  , standardDeviation = standardDeviation
                                  , optimalResult = list(holdings = holdings[optimalIdx,]
                                                         , weights = weights[optimalIdx,]
                                                         , expectedReturn = expectedReturn[optimalIdx]
                                                         , standardDeviation = standardDeviation[optimalIdx]
                                                         , noriskSharpe = expectedReturn[optimalIdx]/standardDeviation[optimalIdx]
                                                         , optimalIndex = optimalIdx
                                  )
  )
  
  return(QuadProgFrontierResults)
  
}
